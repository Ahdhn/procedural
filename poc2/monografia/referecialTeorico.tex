\chapter{REFERENCIAL TEÓRICO}
\label{referencialTeorico}

Para ume melhor compreensão deste trabalho, é necessário explicar o contexto em que ele se situa e também pesquisas relacionadas. O referencial teórico pertinente a este trabalho pode ser dividido em duas áreas: geração procedural e \emph{GPU}. A parte referente à geração procedural será apresentada na Seção \ref{geracaoprocedural}, enquanto que na Seçao \ref{gpu} será apresentada conceitos e trabalhos relativos à programação utilizando a \emph{GPU}.


\section{Geração Procedural}
\label{geracaoprocedural}
Vários trabalhos publicados abordam a geração de modelos tridimensionais com o uso de algoritmos. Alguns destes trabalhos abordam a geração de cidades (\cite{parish} e \cite{pseudoinfinite}), outros abordam a geração de terrenos realistas (em tempo-real, como os trabalhos \cite{realtime} e \cite{virtual}, ou não, como o \emph{MojoWorld} \cite{mojoworld}), ou então a geração de árvores \cite{speedtree}. A principal referência na área é o livro \emph{Texturing and Modeling: A Procedural Approach} \cite{livro}, em que é explicada a geração procedural de diversos tipos de modelos.

Algumas técnicas largamente utilizadas na geração procedural são: Sistemas de Lindenmayer (\emph{l-System})\cite{lsystem}, que, através de uma gramática, modela o crescimento de plantas; geometrias fractais \cite{geometrias}; e também ruído de Perlin (\emph{Perlin noise} \cite{perlin}). Algumas técnicas pertinentes a este trabalho serão abordadas na Seção \ref{terrenos}.

\subsection{Terrenos procedurais}
\label{terrenos}
Existem uma série de técnicas para criação de terrenos proceduralmente, como ruído de Perlin, \emph{fractal plasma}, \emph{fault formation}, \emph{circles}. Para este trabalho, porém, foi escolhido o \emph{Ridged multifractal noise}, uma variação do ruído de Perlin, por este ser o que melhor representa terrenos \cite{livro}.




\subsubsection{Ruído Perlin}
O ruído Perlin foi criado pelo Professor Ken Perlin, da \emph{New York University} e é usado para simular estruturas naturais, como nuvens, texturas de árvores, e terrenos.

A função ruído retorna, para um dado domínio e as mesmas sementes (\emph{seeds}, números entre 0 e 1; dessa forma, em uma segunda execução, com uma mesma semente, teremos os mesmos números entre 0 e 1. Porém, os números não são aleatórios, e aí está a razão da alta aceitação do trabalho de Perlin em áreas como \emph{games} e cinema. 
Cada valor retornado é o resultado do seguinte produto interno:

\begin{center}
G . (P-Q)
\end{center}

Onde P é a posição do ponto que está sendo calculado o valor do ruído, Q é a posição de um de seus vizinhos, e G é o valor de um vetor gradiente pseudo-aleatório. Os resultados do produto interno dos vizinhos é então interpolado, garantindo assim que haverá uma suave transição entre todos os valores retornados.

O resultado, como pode ser visto na Figura \ref{fig:noise} apresenta transições suaves, diferentemente do ruído aleatório.

\begin{figure}[H]
	\center{\includegraphics[width=0.5\linewidth]{img/noise.png}}
	\caption{\label{fig:noise} \emph{Esquerda:} Ruído aleatório. \emph{Direita:} Ruído Perlin.}
\end{figure}


As características fundamentais do ruído Perlin são então a sua aparente aleatoriedade (ao menos para o olho humano); sua capacidade de ser reproduzido, dado os mesmos valores dos gradientes; e sua transição suave entre valores.



\subsubsection{Fractais}
Fractais podem ser descritos, segundo \cite{livro}, como \emph{objetos geométricos complexos, na qual a complexidade surge da repetição de uma forma em uma extensão de escalas}. Um exemplo simples pode ser visto na Figura \ref{fig:fractal}:

\begin{figure}[H]
	\center{\includegraphics[width=0.5\linewidth]{img/fractal.png}}
	\caption{\label{fig:fractal} Exemplo de um fractal a pertir de ruído Perlin.}
\end{figure}

Os quatro ruídos Perlin estão em escalas diferentes e, uma vez somados, formam um fractal, segundo a definição citada. Multifractais já são um subgrupo caracterizado pela variação de sua dimensão fractal ao longo de sua localização.


\subsubsection{\emph{Ridged multifractal noise}}
\label{ridged}
O \emph{Ridged multifractal noise} é uma variação do ruído de Perlin, e foi apresentado em \cite{livro}. O maior ponto do algoritmo é que ele captura a \emph{heterogeneidade de terrenos em grande escala}, apresentando montanhas, planaltos e crateras. Um pseudo-algoritmo pode ser visto na Tabela \ref{tabela:ridged}.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|p{\textwidth}|}
		\hline
\begin{lstlisting}
for(int i=0; i<octaves; i++) {
	float n = ridge(noise(position*freq), offset);
	height += n*amplitude*previous;
	previous = n;
	frequency *= lacunarity;
	amplitude *= gain;
}
	\end{lstlisting}
		\\
		\hline
		\end{tabular}
		\caption{Pseudo-algoritmo do \emph{Ridged multifractal noise}}
		\label{tabela:ridged}
	\end{center}
\end{table}

No algoritmo, o número de \textbf{octaves} representa o número de iterações (e, consequentemente somas) feitas sobre a função de ruído. A \textbf{amplitude} é o máximo valor adicionado ao valor total do ruído. \textbf{Frequency} é o número de valores de ruídos definidos entre dois pontos (quanto maior a frequência, maior o disturbio da textura resultante). \textbf{Lacunarity} é um termo usado no cálculo de fractais, e dita o espaço entre sucessivas frequências, aumentando ou diminuindo a densidade do resultado final. Finalmente, \textbf{offset} é o fator multifractal; a sua variação torna o resultado mais heterogêneo (menor \emph{offset}), ou mais uniforme (maior \emph{offset}).

A função \emph{noise} retorna um valor de acordo com o ruído Perlin, alterado pela função \emph{ridge}, que leva em consideração o fator multifractal (\emph{offset}).


\subsection{Mapa de altura}
\label{mapaaltura}

Um mapa de altura (ou \emph{heightmap}) é uma imagem bidimensional que armazena dados referentes à altura de um terreno. Geralmente, tons mais claros representam pontos mais altos, enquanto tons mais escuros são pontos mais baixos do mapa. A Figura \ref{fig:mapaalturaexemplo} \cite{mapaaltura} é um exemplo de mapa de altura.

\begin{figure}[H]
	\center{\includegraphics[width=0.20\linewidth]{img/mapaaltura.png}}
	\caption{\label{fig:mapaalturaexemplo} Exemplo de um mapa de altura.}
\end{figure}



\section{\emph{GPUs}}
\label{gpu}

As \emph{GPUs} são as unidades de processamento inseridas na maioria das placas de vídeo atuais. A sua evolução foi incentivada pela alta demanda do mercado de renderização 3D em tempo-real, como \emph{games} e simuladores virtuais, sempre em busca de representar a realidade da maneira mais fidedígna possível. A imagem \ref{fig:gflops} mostra a rápida evolução das arquiteturas da \emph{NVidia} (uma das principais produtores de placas de vídeo), considerando o número de operações de pontos flutuantes executados por segundo, em contraste com a evolução das CPUs.

\begin{figure}[H]
	\center{\includegraphics[width=0.5\linewidth]{img/gflops.png}}
	\caption{\label{fig:gflops} Gráfico com a evolução das \emph{GPUs}, em comparação com as \emph{CPUs}.}
\end{figure}

Tamanha diferença evolutiva deve-se, principalmente, ao fato de que as \emph{GPUs} foram construídas de forma a processar da melhor maneira possível um grande número de dados homogêneos e independentes entre si, como é o caso de vértices e \emph{pixels}, base de todo o processamento gráfico. Assim, certos aspectos de um processador, como \emph{cache}, aspectos de sincronização de \emph{threads} e a comunicação entre elas, são relegados.

A programação utilizando \emph{GPUs} iniciou de forma mais concreta no ano de 2001, com a placa \emph{Geforce3}, da \emph{NVidia}. Essa geração permitiu que programas (conhecidos como \emph{shaders}) fossem escritos para serem executados diretamente na \emph{GPU}. Inicialmente, tais programas modificavam os valores e propriedades dos vértices de uma cena. Na geração seguinte (representada pelas placas \emph{GeForce FX}), foi possível também executar \emph{shaders} que modificavam os valores dos \emph{pixels} (ou fragmentos) da cena. A Figura abaixo mostra o \emph{pipeline} gráfico das \emph{GPUs}, destacando a posição das do \emph{vertex shader} e {fragment shader}, sendo estes estágios programáveis.

\begin{figure}[H]
	\center{\includegraphics[width=0.5\linewidth]{img/pipeline.png}}
	\caption{\label{fig:pipeline} \emph{Pipeline} gráfico.}
\end{figure}



Ao longo da evolução das \emph{GPUs}, uma série de linguagens para programação de \emph{shaders} foram criadas. Entre elas, podemos ressaltar a \sigla{HLSL}{High Level Shader Language}, da \emph{Microsoft}, \sigla{Cg}{C for Graphics}, da \emph{NVidia}, e \sigla{GLSL}{OpenGL Shading Language}, da \sigla{OpenGL ARB}{OpenGL Architecture Review Board}.

Ao se utilizar uma dessas linguagens, todo o processamento será feito com base nos vértices (em um \emph{vertex shader}) ou fragmentos (\emph{fragment shader}). O resultado do processamento também ficará limitado a tais primitivas. O destino da renderização de todas as \emph{APIs} é o chamado \emph{Frame Buffer}, que nada mais é do que um vetor com informações sobre cor, profundidade, etc. Como é possível criar novos \emph{Frame buffers}, também é possível criar novos destinos de renderização para os \emph{shaders}.



\section{Geração Procedural utilizando \emph{GPUs}}
A geração procedural de terrenos na \emph{GPU} já foi abordada nos trabalhos \cite{gpugems3} e \cite{Schneider:2006:FractalTerrain}. O primeiro faz uso da plataforma \sigla{CUDA}{Compute Unified Device Architecture}, da empresa \emph{NVidia}, para a geração procedural, e, apesar de mostrar resultados excelentes, está limitado às placas com suporte à \sigla{API}{Application Programming Interface} \emph{DirectX 10}. O trabalho descrito aqui pode ser executado em qualquer placa com suporte a \emph{DirectX 9}.

O segundo trabalho (\cite{Schneider:2006:FractalTerrain}) é o que mais se assemelha ao que é proposto aqui. Ele porém não busca comparar a geração utilizando a \emph{GPU} e a \emph{CPU}.


