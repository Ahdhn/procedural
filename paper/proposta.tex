\section{Metodologia Proposta}
\label{proposta}



O terreno geral é dividido em terrenos retangulares menores (chamados \emph{patches}), como mostra o \emph{grid} da Figura \ref{fig:resultados:grid}. Dessa forma, apenas \emph{patches} de interesse do usuário (que estão mais próximos, por exemplo) precisarão ser gerados.

\begin{figure}[h]
	\center{\includegraphics[width=0.6\linewidth]{img/caps/grid.png}}
	\caption{\label{fig:resultados:grid} \emph{Patches} exibidos em um \emph{grid}.}
\end{figure}

Considerando o usuário inicialmente localizado no \emph{patch} central, ao mover-se para um \emph{patch} vizinho, o sistema irá requisitar a geração de novos \emph{patches}, vizinhos a aqueles que estão na borda do grid. O número de vizinhos gerados, bem como a quantidade de vizinhos do \emph{patch} central são variáveis do sistema, podendo ser adaptadas, pelo usuário, de acordo com o poder de processamento de sua máquina.

Para garantir uma visualização fluida do terreno, minimizando as interrupções com a geração, o sistema proposto decidirá qual arquitetura (GPU ou CPU) será utilizada na geração dos \emph{patches} a partir de uma variável $\alpha$, que representa a porcentagem de gerações que ocorrerão na \emph{GPU}. $1 - \alpha$ representará, portanto a porcentagem de gerações na \emph{CPU}.

A Figura \ref{fig:geracao} mostra como se dá o fluxo de geração.

\begin{figure}[h]
	\center{\includegraphics[width=1.0\linewidth]{img/geracao.pdf}}
	\caption{\label{fig:geracao} Fluxo da geração procedural.}
\end{figure}


As requisições por novos terrenos serão adicionadas a uma fila e uma política \emph{First In, First Out} (FIFO) será utilizada para decidir qual terreno será gerado. Como é possível ver na Figura \ref{fig:geracao}, o número de filas existentes no sistema será igual ao número de vizinhos do \emph{patch} central. Dessa forma, é possível decidir quais terrenos serão gerados a partir de sua distância do \emph{patch} central.

A \emph{thread 0} (principal) ficará encarregada da requisição para gerar novos eventos, avaliação da fila, avaliação da arquitetura a ser utilizada (GPU ou CPU), e também será responsável pelas chamadas às funções OpenGL, incluindo aquelas responsáveis por iniciar a execução das instruções que serão executadas na GPU. A geração na CPU ocorrerá em outras \emph{threads}, não a principal.



\subsection{O Cálculo de $\alpha$}

O valor da variável $\alpha$ é, atualmente, controlado manualmente pelo usuário.  A sua variação de acordo com a utilização de cada arquitetura será um tema a ser abordado em trabalhos futuros.

Atualmente, a maior dificuldade para medir o tempo de geração tanto na GPU é a falta de um padrão nas extensões disponíveis em OpenGL. A extensão \textbf{GL\_EXT\_timer\_query}, por exemplo, só está disponível em placas NVidia, algo que anularia a possibilidade da execução deste trabalho em placas ATI.

A utilização de chamadas como \textbf{glFinish()} para sincronizar a CPU e a GPU e assim medir o tempo de geração dos terrenos poderia prejudicar a performance do sistema, já que pára a execução da CPU enquanto todos os os comandos OpenGL não forem executados.

Uma outra opção para a sincronização seria a extensão \textbf{GL\_NV\_fence}, que oferece funções para sincronização semelhantes ao \textbf{glFinish()} e \textbf{glFlush()}, porém com um grau maior de controle sobre quais comandos OpenGL deverão ser executados na chamada. Mais uma vez, porém, a extensão não está disponível para placas ATI.

\subsection{Geração}
Toda a geração dos terrenos na GPU é feita através de um \emph{fragment shader} (versão 3.0), utilizando o ruído Perlin como foi proposto em \cite{improvedPerlinNoise}. Como toda computação de \emph{shaders} fica limitada a geometrias ou texturas, foi preciso renderizar um quadrado utilizando as funções OpenGL, para que, dessa forma, fosse possível aplicar os \emph{shaders} às suas primitivas e iniciar os cálculos necessários. O resultado da geração é renderizado em um \emph{framebuffer} \emph{off-screen} (que não é exibido na tela), através da extenção FBO, que permite criar novos \emph{buffers}.

O cálculo dos vetores gradientes, necessário no ruído Perlin, é feito na CPU, apenas no início do sistema, e depois é acessado no \emph{fragment shader} como uma textura 2D.

Como o mapa de altura é gerado na GPU, não há qualquer tipo de perda de desempenho com a transferência entre a memória RAM e a memória da placa de vídeo. Um aspecto importante é que, durante a geração do mapa de altura, os valores das normais de cada vértice também são calculados.

A geração utilizando a CPU é feita utilizando o mesmo algoritmo implementado na GPU. Como o mapa de altura gerado reside na memória principal, sua renderização dependerá da transferência para a memória da placa de vídeo.


\subsection{Visualização}
Com o mapa de altura gerado, o próximo passo é exibir o terreno para o usuário, que é feito de forma idêntica tanto para os terrenos gerados na GPU quanto para os gerados na CPU.

O passo inicial é a geração de uma malha (conjunto de vértices) de tamanho pré-determinado, como mostra a Figura \ref{fig:malha}. A malha é gerada de tal forma que um número maior de vértices está concentrado no centro. Quanto maior a distância, menor o número de vértices presentes. Isto propicia uma maneira rápida e fácil de implementar um algoritmo de nível de detalhe (quanto maior a distância do centro, menor será a necessidade de se renderizar o terreno em alta fidelidade).

\begin{figure}[h]
	\center{\includegraphics[width=0.5\linewidth]{img/caps/malha.png}}
	\caption{\label{fig:malha} Malha inicial para visualização dos terrenos.}
\end{figure}

Como a malha é gerada apenas uma única vez (no início da execução), não é preciso criar repetidas malhas a medida que o jogador percorre o terreno. Apenas os mapas de altura de cada \emph{patch} são trocados, como mostra a Figura \ref{fig:texturas}

\begin{figure}[h]
	\center{\includegraphics[width=0.8\linewidth]{img/texturas.pdf}}
	\caption{\label{fig:texturas} Movimentação da câmera para um outro \emph{patches}.}
\end{figure}

Na Figura \ref{fig:texturas} é possível notar o deslocamento dos mapas de altura quando a câmera move para o \emph{patch} superior ao (1,1). Para que haja uma transição, uma matriz de translação, com valores iguais ao tamanho do \emph{patch}, é feita e multiplicada à matriz responsável por renderizar todas as primitivas, resultando na translação de todos os \emph{patches}. 

Este algoritmo de nível de detalhe se mostrou bastante eficaz para este trabalho, não sendo necessária a implementação de um algoritmo LOD mais robusto. Além disso, como sabemos o número de vértices antecipadamente, a performance do aplicativo tem uma menor chance de sofrer quedas bruscas de rendimento.

